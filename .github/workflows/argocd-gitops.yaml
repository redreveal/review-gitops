name: Review-GitOps Manual Modifications

on:
  push:
    branches:
      - main

jobs:
  determine-environment:
    runs-on: ubuntu-latest
    outputs:
      prod_changed: ${{ steps.determine-env.outputs.prod_changed }}
      non_prod_changed: ${{ steps.determine-env.outputs.non_prod_changed }}
      regions_envs_json: ${{ steps.determine-env.outputs.regions_envs_json }}
    steps:
      - name: Checkout Repository
        uses: actions/checkout@v2

      - name: Determine Environment Based on Modified Files
        id: determine-env
        uses: actions/github-script@v5
        with:
          script: |
            const payload = context.payload;
            const repo = context.repo;
            let base, head;

            if (payload.pull_request) {
              base = payload.pull_request.base.sha;
              head = payload.pull_request.head.sha;
            } else {
              base = payload.before;
              head = payload.after;
            }

            const compare = await github.rest.repos.compareCommits({
              owner: repo.owner,
              repo: repo.repo,
              base: base,
              head: head
            });

            let prod_changed = false;
            let non_prod_changed = false;
            const regions_envs = [];

            compare.data.files.forEach(file => {
              if (file.filename.startsWith('prod/')) {
                prod_changed = true;
                let region = file.filename.split('/')[1];
                regions_envs.push({region, env: 'prod', branch: 'production'});
              } else if (file.filename.startsWith('dev/') || file.filename.startsWith('uat/')) {
                non_prod_changed = true;
                let env = file.filename.startsWith('dev/') ? 'dev' : 'uat';
                let region = file.filename.split('/')[1];
                regions_envs.push({region, env, branch: env === 'dev' ? 'develop' : 'uat'});
              }
            });

            const fs = require('fs');
            fs.writeFileSync('regions_envs.json', JSON.stringify(regions_envs));
            core.setOutput('prod_changed', prod_changed);
            core.setOutput('non_prod_changed', non_prod_changed);
            core.setOutput('regions_envs_json', JSON.stringify(regions_envs));

  process-values:
    needs: determine-environment
    runs-on: ubuntu-latest
    strategy:
      matrix:
        environment: [production, dev-uat]
    if: ${{ needs.determine-environment.outputs.prod_changed == 'true' && matrix.environment == 'production' || needs.determine-environment.outputs.non_prod_changed == 'true' && matrix.environment == 'dev-uat' }}
    environment: ${{ matrix.environment }}
    steps:
      - name: Checkout Review-GitOps
        uses: actions/checkout@v2
        with:
          repository: redreveal/review-gitops
          token: ${{ secrets.TOKEN }}
          path: review-gitops

      - name: Checkout Terraform Repo
        uses: actions/checkout@v2
        with:
          repository: redreveal/red-terraform
          token: ${{ secrets.TOKEN }}
          path: terraform

      - name: Checkout ArgoCD-GitOps Repo
        uses: actions/checkout@v2
        with:
          repository: redreveal/argocd-gitops-versions
          token: ${{ secrets.TOKEN }}
          path: argocd-gitops

      - name: Install yq and jq
        run: |
          sudo wget https://github.com/mikefarah/yq/releases/download/v4.6.1/yq_linux_amd64 -O /usr/bin/yq
          sudo chmod +x /usr/bin/yq
          sudo apt-get install -y jq

      - name: Extract MSA Numbers
        run: |
          regions_envs=$(echo '${{ needs.determine-environment.outputs.regions_envs_json }}' | jq -r '.[] | @base64')
          for region_env in $regions_envs; do
            _jq() {
              echo ${region_env} | base64 --decode | jq -r ${1}
            }
            REGION=$(_jq '.region')
            ENV=$(_jq '.env')
            BRANCH=$(_jq '.branch')

            echo "Checking out branch $BRANCH for $ENV/$REGION"
            cd terraform
            git fetch origin
            git checkout $BRANCH
            git pull origin $BRANCH

            MAIN_TF="${ENV}/$REGION/99_clients/main.tf"
            echo "Extracting MSA numbers for $ENV/$REGION from $MAIN_TF"
            grep 'module.MSA' $MAIN_TF | egrep -o '[0-9]+' | sort -u > ../msa_numbers_${ENV}_${REGION}.txt
            cd ..
          done

      - name: Handle Symlinks for Overridden and Non-Overridden MSAs
        run: |
          regions_envs=$(echo '${{ needs.determine-environment.outputs.regions_envs_json }}' | jq -r '.[] | @base64')
          for region_env in $regions_envs; do
            _jq() {
              echo ${region_env} | base64 --decode | jq -r ${1}
            }
            REGION=$(_jq '.region')
            ENV=$(_jq '.env')

            ALL_MSAS=$(cat msa_numbers_${ENV}_${REGION}.txt | sort -u)
            OVERRIDDEN_MSAS=$(yq eval '.msas | keys' review-gitops/${ENV}/${REGION}/versions.yaml | grep -o '[0-9]\+')

            for MSA in $ALL_MSAS; do
              FILE="argocd-gitops/review/${ENV}/${REGION}/$MSA.yaml"
              DEFAULT_VALUES_FILE="argocd-gitops/review/${ENV}/${REGION}/default_values.yaml"

              if echo "$OVERRIDDEN_MSAS" | grep -q "$MSA"; then
                if [ -L $FILE ]; then
                  echo "Removing symlink for overridden MSA $MSA in $FILE"
                  rm $FILE
                fi
              else
                if [ -f $FILE ] && [ ! -L $FILE ]; then
                  echo "Converting $FILE back to a symlink to default_values.yaml"
                  rm $FILE
                  ln -sf ./default_values.yaml $FILE
                fi
              done
            done
          done

      - name: Set up Python
        uses: actions/setup-python@v2
        with:
          python-version: '3.x'

      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install pyyaml

      - name: Run the Python script to generate values.yaml
        run: |
          regions_envs=$(echo '${{ needs.determine-environment.outputs.regions_envs_json }}' | jq -r '.[] | @base64')
          for region_env in $regions_envs; do
            _jq() {
              echo ${region_env} | base64 --decode | jq -r ${1}
            }
            REGION=$(_jq '.region')
            ENV=$(_jq '.env')
            python review-gitops/.github/actions/scripts/process_values.py review-gitops/${ENV}/${REGION}/versions.yaml argocd-gitops/review/${ENV}/${REGION}
          done

      - name: Check file changes for Image verification
        run: |
          cd argocd-gitops
          git diff --name-only | grep 'review/' | sed "s|^|$(pwd)/|" > ../modified_files.txt
          cat ../modified_files.txt

      - name: Install Helm
        run: |
          curl -sSL https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash

      - name: Generate Helm Template and Verify Tags
        run: |
          helm repo add redon-chart-repo https://redon-cdn.s3.amazonaws.com/
          helm repo update
          
          while IFS= read -r values_file; do
            echo "Processing $values_file"
            helm template redon-chart-repo/argopoc --values $values_file > rendered_template.yaml
      
            grep 'image:' rendered_template.yaml | while read -r line ; do
              repo=$(echo $line | awk -F: '{print $2}' | sed 's| //||g' | awk -F/ '{print $2}')
              tag=$(echo $line | awk -F: '{print $3}')
              
              if [ -z "$repo" ] || [ -z "$tag" ]; then
                echo "Failed to parse repo or tag from line: $line"
                exit 1
              fi

              echo "Checking tag $tag for repository $repo in file $values_file"
              #aws ecr describe-images --repository-name $repo --image-ids imageTag=$tag || exit 1
              echo "Tag $tag exists in ECR for repo $repo"
            done
          done < ../modified_files.txt

      - name: Create Symlinks for Non-Overridden MSAs
        run: |
          regions_envs=$(echo '${{ needs.determine-environment.outputs.regions_envs_json }}' | jq -r '.[] | @base64')
          for region_env in $regions_envs; do
            _jq() {
              echo ${region_env} | base64 --decode | jq -r ${1}
            }
            REGION=$(_jq '.region')
            ENV=$(_jq '.env')

            MSAS=$(cat msa_numbers_${ENV}_${REGION}.txt | sort -u)
            for MSA in $MSAS; do
              DIRECTORY="argocd-gitops/review/${ENV}/${REGION}"
              FILE="$DIRECTORY/$MSA.yaml"
              DEFAULT_VALUES_FILE="argocd-gitops/review/${ENV}/${REGION}/default_values.yaml"

              if [ ! -f $FILE ]; then
                echo "Creating symlink for MSA $MSA to default_values.yaml"
                ln -sf ./default_values.yaml $FILE
              fi
            done
          done

      - name: Show Differences
        run: |
          cd argocd-gitops
          git diff

      - name: Commit and Push Updates
        run: |
          cd argocd-gitops
          git config user.email "rberisha@revealdata.com"
          git config user.name "Redon Berisha"
          git add .
          git commit -m "Updated from Review-GitOps" || echo "No changes to commit"
          git push
        env:
          GITHUB_TOKEN: ${{ secrets.TOKEN }}
